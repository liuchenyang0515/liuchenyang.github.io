<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>你真的了解回流和重绘吗 | 砖业洋__</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/haizei.jpg">
    <meta name="description" content="">
    <link rel="preload" href="/assets/css/0.styles.1f351a1e.css" as="style"><link rel="preload" href="/assets/js/app.81ae6b7f.js" as="script"><link rel="preload" href="/assets/js/2.5bd328db.js" as="script"><link rel="preload" href="/assets/js/3.90e623d3.js" as="script"><link rel="preload" href="/assets/js/6.ac0983fc.js" as="script"><link rel="prefetch" href="/assets/js/10.d54e1c21.js"><link rel="prefetch" href="/assets/js/11.c6a9d2fd.js"><link rel="prefetch" href="/assets/js/12.34c7898c.js"><link rel="prefetch" href="/assets/js/4.5879dcd7.js"><link rel="prefetch" href="/assets/js/5.b6bfb626.js"><link rel="prefetch" href="/assets/js/7.46572acb.js"><link rel="prefetch" href="/assets/js/8.2b398bc4.js"><link rel="prefetch" href="/assets/js/9.f2979413.js">
    <link rel="stylesheet" href="/assets/css/0.styles.1f351a1e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><!----> <!----> <header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/haizei.jpg" alt="砖业洋__" class="logo"> <span class="site-name can-hide">砖业洋__</span></a> <div class="links"><span>你好，砖业洋__持续为你分享    </span> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://liuchenyang0515.blog.csdn.net" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN主页
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://liuchenyang0515.blog.csdn.net" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN主页
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>你真的了解回流和重绘吗</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/tech/nizhendeliaojiehuiliuhechonghuima.html#浏览器的渲染过程" class="sidebar-link">浏览器的渲染过程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tech/nizhendeliaojiehuiliuhechonghuima.html#生成渲染树" class="sidebar-link">生成渲染树</a></li><li class="sidebar-sub-header"><a href="/tech/nizhendeliaojiehuiliuhechonghuima.html#回流" class="sidebar-link">回流</a></li><li class="sidebar-sub-header"><a href="/tech/nizhendeliaojiehuiliuhechonghuima.html#重绘" class="sidebar-link">重绘</a></li></ul></li><li><a href="/tech/nizhendeliaojiehuiliuhechonghuima.html#何时发生回流重绘" class="sidebar-link">何时发生回流重绘</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/nizhendeliaojiehuiliuhechonghuima.html#浏览器的优化机制" class="sidebar-link">浏览器的优化机制</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/nizhendeliaojiehuiliuhechonghuima.html#减少回流和重绘" class="sidebar-link">减少回流和重绘</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tech/nizhendeliaojiehuiliuhechonghuima.html#最小化重绘和重排" class="sidebar-link">最小化重绘和重排</a></li><li class="sidebar-sub-header"><a href="/tech/nizhendeliaojiehuiliuhechonghuima.html#批量修改dom" class="sidebar-link">批量修改DOM</a></li><li class="sidebar-sub-header"><a href="/tech/nizhendeliaojiehuiliuhechonghuima.html#避免触发同步布局事件" class="sidebar-link">避免触发同步布局事件</a></li><li class="sidebar-sub-header"><a href="/tech/nizhendeliaojiehuiliuhechonghuima.html#对于复杂动画效果-使用绝对定位让其脱离文档流" class="sidebar-link">对于复杂动画效果,使用绝对定位让其脱离文档流</a></li><li class="sidebar-sub-header"><a href="/tech/nizhendeliaojiehuiliuhechonghuima.html#css3硬件加速（gpu加速）" class="sidebar-link">css3硬件加速（GPU加速）</a></li></ul></li><li><a href="/tech/nizhendeliaojiehuiliuhechonghuima.html#总结" class="sidebar-link">总结</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/tech/nizhendeliaojiehuiliuhechonghuima.html#参考文献" class="sidebar-link">参考文献</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="你真的了解回流和重绘吗"><a href="#你真的了解回流和重绘吗" class="header-anchor">#</a> 你真的了解回流和重绘吗</h1> <blockquote><p>作者：chenjigeng</p></blockquote> <p>回流和重绘可以说是每一个web开发者都经常听到的两个词语，我也不例外，可是我之前一直不是很清楚这两步具体做了什么事情。最近由于部门内部要做分享，所以对其进行了一些研究，看了一些博客和书籍，整理了一些内容并且结合一些例子，写了这篇文章，希望可以帮助到大家。</p> <h2 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="header-anchor">#</a> 浏览器的渲染过程</h2> <p>本文先从浏览器的渲染过程来从头到尾的讲解一下回流重绘，如果大家想直接看如何减少回流和重绘，可以跳到后面。（这个渲染过程来自<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn" target="_blank" rel="noopener noreferrer">MDN<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）</p> <p><img src="/assets/img/dom_render.89b6070a.png" alt="DOM渲染"></p> <p>从上面这个图上，我们可以看到，浏览器渲染过程如下：</p> <ol><li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li> <li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li> <li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li> <li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li> <li>Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客）</li></ol> <p>渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。</p> <h3 id="生成渲染树"><a href="#生成渲染树" class="header-anchor">#</a> 生成渲染树</h3> <p><img src="/assets/img/generate_render_tree.94866059.png" alt="生成渲染树"></p> <p>为了构建渲染树，浏览器主要完成了以下工作：</p> <ol><li>从DOM树的根节点开始遍历每个可见节点。</li> <li>对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。</li> <li>根据每个可见节点以及其对应的样式，组合生成渲染树。</li></ol> <p>第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：</p> <ul><li>一些不会渲染输出的节点，比如script、meta、link等。</li> <li>一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。</li></ul> <p><strong>注意：渲染树只包含可见的节点</strong></p> <h3 id="回流"><a href="#回流" class="header-anchor">#</a> 回流</h3> <p>前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。</p> <p>为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历，我们可以以下面这个实例来表示：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype">&lt;!DOCTYPE html&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>viewport<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>width=device-width,initial-scale=1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Critial Path: Hello world!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">=&quot;</span><span class="token attr-value"><span class="token property">width</span><span class="token punctuation">:</span> 50%</span><span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">=&quot;</span><span class="token attr-value"><span class="token property">width</span><span class="token punctuation">:</span> 50%</span><span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Hello world!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>我们可以看到，第一个div将节点的显示尺寸设置为视口宽度的50%，第二个div将其尺寸设置为父节点的50%。而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值。（如下图）
<img src="data:image/png;base64,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" alt="渲染章节的viewport"></p> <h3 id="重绘"><a href="#重绘" class="header-anchor">#</a> 重绘</h3> <p>最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。</p> <p>既然知道了浏览器的渲染过程后，我们就来探讨下，何时会发生回流重绘。</p> <h2 id="何时发生回流重绘"><a href="#何时发生回流重绘" class="header-anchor">#</a> 何时发生回流重绘</h2> <p>我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：</p> <ul><li>添加或删除可见的DOM元素</li> <li>元素的位置发生变化</li> <li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li> <li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li> <li>页面一开始渲染的时候（这肯定避免不了）</li> <li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li></ul> <p><strong>注意：回流一定会触发重绘，而重绘不一定会回流</strong></p> <p>根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。</p> <h2 id="浏览器的优化机制"><a href="#浏览器的优化机制" class="header-anchor">#</a> 浏览器的优化机制</h2> <p>现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！<strong>当你获取布局信息的操作的时候，会强制队列刷新</strong>，比如当你访问以下属性或者使用以下方法：</p> <ul><li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li> <li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li> <li>clientTop、clientLeft、clientWidth、clientHeight</li> <li>getComputedStyle()</li> <li>getBoundingClientRect</li> <li>具体可以访问这个网站：<a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a" target="_blank" rel="noopener noreferrer">gist.github.com/paulirish/5…<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，**最好避免使用上面列出的属性，他们都会刷新渲染队列。**如果要使用它们，最好将值缓存起来。</p> <h2 id="减少回流和重绘"><a href="#减少回流和重绘" class="header-anchor">#</a> 减少回流和重绘</h2> <p>好了，到了我们今天的重头戏，前面说了这么多背景和理论知识，接下来让我们谈谈如何减少回流和重绘。</p> <h3 id="最小化重绘和重排"><a href="#最小化重绘和重排" class="header-anchor">#</a> 最小化重绘和重排</h3> <p>由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉。考虑这个例子</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>padding <span class="token operator">=</span> <span class="token string">'5px'</span><span class="token punctuation">;</span>
el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>borderLeft <span class="token operator">=</span> <span class="token string">'1px'</span><span class="token punctuation">;</span>
el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>borderRight <span class="token operator">=</span> <span class="token string">'2px'</span><span class="token punctuation">;</span>
</code></pre></div><p>例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。</p> <p>因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式：</p> <ul><li>使用cssText</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText <span class="token operator">+=</span> <span class="token string">'border-left: 1px; border-right: 2px; padding: 5px;'</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>修改CSS的class</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
el<span class="token punctuation">.</span>className <span class="token operator">+=</span> <span class="token string">' active'</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="批量修改dom"><a href="#批量修改dom" class="header-anchor">#</a> 批量修改DOM</h3> <p>当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数：</p> <ol><li>使元素脱离文档流</li> <li>对其进行多次修改</li> <li>将元素带回到文档中。</li></ol> <p>该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流，因为它已经不在渲染树了。</p> <p>有三种方式可以让DOM脱离文档流：</p> <ul><li>隐藏元素，应用修改，重新显示</li> <li>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。</li> <li>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</li></ul> <p>考虑我们要执行一段批量插入节点的代码：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">appendDataToElement</span><span class="token punctuation">(</span><span class="token parameter">appendToElement<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> li<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	li <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        li<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">'text'</span><span class="token punctuation">;</span>
        appendToElement<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'list'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">appendDataToElement</span><span class="token punctuation">(</span>ul<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。</p> <p>我们可以使用这三种方式进行优化:</p> <p><strong>隐藏元素，应用修改，重新显示</strong></p> <p>这个会在展示和隐藏节点的时候，产生两次重绘</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">appendDataToElement</span><span class="token punctuation">(</span><span class="token parameter">appendToElement<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> li<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	li <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        li<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">'text'</span><span class="token punctuation">;</span>
        appendToElement<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'list'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ul<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'none'</span><span class="token punctuation">;</span>
<span class="token function">appendDataToElement</span><span class="token punctuation">(</span>ul<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
ul<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'block'</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'list'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> fragment <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">appendDataToElement</span><span class="token punctuation">(</span>fragment<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
ul<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>fragment<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'list'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> clone <span class="token operator">=</span> ul<span class="token punctuation">.</span><span class="token function">cloneNode</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">appendDataToElement</span><span class="token punctuation">(</span>clone<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
ul<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span>clone<span class="token punctuation">,</span> ul<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>对于上述那种情况，我写了一个<a href="https://chenjigeng.github.io/example/share/%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9DOM.html" target="_blank" rel="noopener noreferrer">demo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>来测试修改前和修改后的性能。然而实验结果不是很理想。</p> <p><strong>原因：原因其实上面也说过了，浏览器会使用队列来储存多次修改，进行优化，所以对这个优化方案，我们其实不用优先考虑。</strong></p> <h3 id="避免触发同步布局事件"><a href="#避免触发同步布局事件" class="header-anchor">#</a> 避免触发同步布局事件</h3> <p>上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">initP</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> paragraphs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        paragraphs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>width <span class="token operator">=</span> box<span class="token punctuation">.</span>offsetWidth <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。每一次循环都会强制浏览器刷新队列。我们可以优化为:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> width <span class="token operator">=</span> box<span class="token punctuation">.</span>offsetWidth<span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">initP</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> paragraphs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        paragraphs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>width <span class="token operator">=</span> width <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>同样，我也写了个<a href="https://chenjigeng.github.io/example/share/%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98/%E9%81%BF%E5%85%8D%E5%BF%AB%E9%80%9F%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%B8%83%E5%B1%80.html" target="_blank" rel="noopener noreferrer">demo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>来比较两者的性能差异。你可以自己点开这个demo体验下。这个对比差距就比较明显。</p> <h3 id="对于复杂动画效果-使用绝对定位让其脱离文档流"><a href="#对于复杂动画效果-使用绝对定位让其脱离文档流" class="header-anchor">#</a> 对于复杂动画效果,使用绝对定位让其脱离文档流</h3> <p>对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。这个我们就直接上个<a href="https://chenjigeng.github.io/example/share/%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98/%E5%B0%86%E5%A4%8D%E6%9D%82%E5%8A%A8%E7%94%BB%E6%B5%AE%E5%8A%A8%E5%8C%96.html" target="_blank" rel="noopener noreferrer">例子<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>打开这个例子后，我们可以打开控制台，控制台上会输出当前的帧数(虽然不准)。
<img src="/assets/img/example_demo_animation.8b6d696e.png" alt="">
从上图中，我们可以看到，帧数一直都没到60。这个时候，只要我们点击一下那个按钮，把这个元素设置为绝对定位，帧数就可以稳定60。</p> <h3 id="css3硬件加速（gpu加速）"><a href="#css3硬件加速（gpu加速）" class="header-anchor">#</a> css3硬件加速（GPU加速）</h3> <p>比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3硬件加速就闪亮登场啦！！</p> <p><strong>划重点：使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</strong></p> <p>本篇文章只讨论如何使用，暂不考虑其原理，之后有空会另外开篇文章说明。</p> <h4 id="如何使用"><a href="#如何使用" class="header-anchor">#</a> 如何使用</h4> <p>常见的触发硬件加速的css属性：</p> <ul><li>transform</li> <li>opacity</li> <li>filters</li> <li>Will-change</li></ul> <h4 id="效果"><a href="#效果" class="header-anchor">#</a> 效果</h4> <p>我们可以先看个<a href="https://chenjigeng.github.io/example/share/%E5%AF%B9%E6%AF%94gpu%E5%8A%A0%E9%80%9F/gpu%E5%8A%A0%E9%80%9F-transform.html" target="_blank" rel="noopener noreferrer">例子<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。我通过使用chrome的Performance捕获了一段时间的回流重绘情况，实际结果如下图：</p> <p><img src="data:image/png;base64,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" alt=""></p> <p>从图中我们可以看出，在动画进行的时候，没有发生任何的回流重绘。如果感兴趣你也可以自己做下实验。</p> <h4 id="重点"><a href="#重点" class="header-anchor">#</a> 重点</h4> <ul><li>使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘</li> <li>对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</li></ul> <h4 id="css3硬件加速的坑"><a href="#css3硬件加速的坑" class="header-anchor">#</a> css3硬件加速的坑</h4> <ul><li>如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。</li> <li>在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。</li></ul> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>本文主要讲了浏览器的渲染过程、浏览器的优化机制以及如何减少甚至避免回流和重绘，希望可以帮助大家更好的理解回流重绘。</p> <h2 id="参考文献"><a href="#参考文献" class="header-anchor">#</a> 参考文献</h2> <ul><li><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn" target="_blank" rel="noopener noreferrer">渲染树构建、布局及绘制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>高性能Javascript</li></ul> <br> <!----></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.81ae6b7f.js" defer></script><script src="/assets/js/2.5bd328db.js" defer></script><script src="/assets/js/3.90e623d3.js" defer></script><script src="/assets/js/6.ac0983fc.js" defer></script>
  </body>
</html>
